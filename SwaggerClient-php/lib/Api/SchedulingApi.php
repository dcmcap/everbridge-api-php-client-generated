<?php
/**
 * SchedulingApi
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * Rest Api
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 3.x
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.21
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Swagger\Client\ApiException;
use Swagger\Client\Configuration;
use Swagger\Client\HeaderSelector;
use Swagger\Client\ObjectSerializer;

/**
 * SchedulingApi Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class SchedulingApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createCalendarsUsingPOST
     *
     * Create calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A calendars object to be created. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function createCalendarsUsingPOST($authorization, $organization_id, $data)
    {
        list($response) = $this->createCalendarsUsingPOSTWithHttpInfo($authorization, $organization_id, $data);
        return $response;
    }

    /**
     * Operation createCalendarsUsingPOSTWithHttpInfo
     *
     * Create calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A calendars object to be created. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function createCalendarsUsingPOSTWithHttpInfo($authorization, $organization_id, $data)
    {
        $returnType = 'object';
        $request = $this->createCalendarsUsingPOSTRequest($authorization, $organization_id, $data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createCalendarsUsingPOSTAsync
     *
     * Create calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A calendars object to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCalendarsUsingPOSTAsync($authorization, $organization_id, $data)
    {
        return $this->createCalendarsUsingPOSTAsyncWithHttpInfo($authorization, $organization_id, $data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createCalendarsUsingPOSTAsyncWithHttpInfo
     *
     * Create calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A calendars object to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createCalendarsUsingPOSTAsyncWithHttpInfo($authorization, $organization_id, $data)
    {
        $returnType = 'object';
        $request = $this->createCalendarsUsingPOSTRequest($authorization, $organization_id, $data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createCalendarsUsingPOST'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A calendars object to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createCalendarsUsingPOSTRequest($authorization, $organization_id, $data)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createCalendarsUsingPOST'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createCalendarsUsingPOST'
            );
        }
        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling createCalendarsUsingPOST'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/calendars';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createShiftScheduleUsingPOST
     *
     * Create ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A ShiftSchedule object or array of substitution objects to be created. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function createShiftScheduleUsingPOST($authorization, $organization_id, $data)
    {
        list($response) = $this->createShiftScheduleUsingPOSTWithHttpInfo($authorization, $organization_id, $data);
        return $response;
    }

    /**
     * Operation createShiftScheduleUsingPOSTWithHttpInfo
     *
     * Create ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A ShiftSchedule object or array of substitution objects to be created. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function createShiftScheduleUsingPOSTWithHttpInfo($authorization, $organization_id, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->createShiftScheduleUsingPOSTRequest($authorization, $organization_id, $data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createShiftScheduleUsingPOSTAsync
     *
     * Create ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A ShiftSchedule object or array of substitution objects to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createShiftScheduleUsingPOSTAsync($authorization, $organization_id, $data)
    {
        return $this->createShiftScheduleUsingPOSTAsyncWithHttpInfo($authorization, $organization_id, $data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createShiftScheduleUsingPOSTAsyncWithHttpInfo
     *
     * Create ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A ShiftSchedule object or array of substitution objects to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createShiftScheduleUsingPOSTAsyncWithHttpInfo($authorization, $organization_id, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->createShiftScheduleUsingPOSTRequest($authorization, $organization_id, $data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createShiftScheduleUsingPOST'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A ShiftSchedule object or array of substitution objects to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createShiftScheduleUsingPOSTRequest($authorization, $organization_id, $data)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createShiftScheduleUsingPOST'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createShiftScheduleUsingPOST'
            );
        }
        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling createShiftScheduleUsingPOST'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/shiftSchedules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createShiftSubstitutionsUsingPOST
     *
     * Create shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object or array of substitution objects to be created. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function createShiftSubstitutionsUsingPOST($authorization, $organization_id, $data)
    {
        list($response) = $this->createShiftSubstitutionsUsingPOSTWithHttpInfo($authorization, $organization_id, $data);
        return $response;
    }

    /**
     * Operation createShiftSubstitutionsUsingPOSTWithHttpInfo
     *
     * Create shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object or array of substitution objects to be created. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function createShiftSubstitutionsUsingPOSTWithHttpInfo($authorization, $organization_id, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->createShiftSubstitutionsUsingPOSTRequest($authorization, $organization_id, $data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createShiftSubstitutionsUsingPOSTAsync
     *
     * Create shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object or array of substitution objects to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createShiftSubstitutionsUsingPOSTAsync($authorization, $organization_id, $data)
    {
        return $this->createShiftSubstitutionsUsingPOSTAsyncWithHttpInfo($authorization, $organization_id, $data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createShiftSubstitutionsUsingPOSTAsyncWithHttpInfo
     *
     * Create shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object or array of substitution objects to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createShiftSubstitutionsUsingPOSTAsyncWithHttpInfo($authorization, $organization_id, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->createShiftSubstitutionsUsingPOSTRequest($authorization, $organization_id, $data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createShiftSubstitutionsUsingPOST'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object or array of substitution objects to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createShiftSubstitutionsUsingPOSTRequest($authorization, $organization_id, $data)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createShiftSubstitutionsUsingPOST'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createShiftSubstitutionsUsingPOST'
            );
        }
        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling createShiftSubstitutionsUsingPOST'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/shiftSubstitutions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createStaffSchedulesUsingPOST
     *
     * Create StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A StaffSchedule object or array of substitution objects to be created. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function createStaffSchedulesUsingPOST($authorization, $organization_id, $data)
    {
        list($response) = $this->createStaffSchedulesUsingPOSTWithHttpInfo($authorization, $organization_id, $data);
        return $response;
    }

    /**
     * Operation createStaffSchedulesUsingPOSTWithHttpInfo
     *
     * Create StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A StaffSchedule object or array of substitution objects to be created. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function createStaffSchedulesUsingPOSTWithHttpInfo($authorization, $organization_id, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->createStaffSchedulesUsingPOSTRequest($authorization, $organization_id, $data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createStaffSchedulesUsingPOSTAsync
     *
     * Create StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A StaffSchedule object or array of substitution objects to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStaffSchedulesUsingPOSTAsync($authorization, $organization_id, $data)
    {
        return $this->createStaffSchedulesUsingPOSTAsyncWithHttpInfo($authorization, $organization_id, $data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createStaffSchedulesUsingPOSTAsyncWithHttpInfo
     *
     * Create StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A StaffSchedule object or array of substitution objects to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createStaffSchedulesUsingPOSTAsyncWithHttpInfo($authorization, $organization_id, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->createStaffSchedulesUsingPOSTRequest($authorization, $organization_id, $data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createStaffSchedulesUsingPOST'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A StaffSchedule object or array of substitution objects to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createStaffSchedulesUsingPOSTRequest($authorization, $organization_id, $data)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createStaffSchedulesUsingPOST'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createStaffSchedulesUsingPOST'
            );
        }
        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling createStaffSchedulesUsingPOST'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/staffSchedules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSubstitutionsUsingPOST
     *
     * Create scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object or array of substitution objects to be created. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function createSubstitutionsUsingPOST($authorization, $organization_id, $data)
    {
        list($response) = $this->createSubstitutionsUsingPOSTWithHttpInfo($authorization, $organization_id, $data);
        return $response;
    }

    /**
     * Operation createSubstitutionsUsingPOSTWithHttpInfo
     *
     * Create scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object or array of substitution objects to be created. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function createSubstitutionsUsingPOSTWithHttpInfo($authorization, $organization_id, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->createSubstitutionsUsingPOSTRequest($authorization, $organization_id, $data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation createSubstitutionsUsingPOSTAsync
     *
     * Create scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object or array of substitution objects to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSubstitutionsUsingPOSTAsync($authorization, $organization_id, $data)
    {
        return $this->createSubstitutionsUsingPOSTAsyncWithHttpInfo($authorization, $organization_id, $data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSubstitutionsUsingPOSTAsyncWithHttpInfo
     *
     * Create scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object or array of substitution objects to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSubstitutionsUsingPOSTAsyncWithHttpInfo($authorization, $organization_id, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->createSubstitutionsUsingPOSTRequest($authorization, $organization_id, $data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSubstitutionsUsingPOST'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object or array of substitution objects to be created. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function createSubstitutionsUsingPOSTRequest($authorization, $organization_id, $data)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling createSubstitutionsUsingPOST'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling createSubstitutionsUsingPOST'
            );
        }
        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling createSubstitutionsUsingPOST'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/substitutions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteCalendarsUsingDELETE
     *
     * Delete calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function deleteCalendarsUsingDELETE($authorization, $organization_id, $ids)
    {
        list($response) = $this->deleteCalendarsUsingDELETEWithHttpInfo($authorization, $organization_id, $ids);
        return $response;
    }

    /**
     * Operation deleteCalendarsUsingDELETEWithHttpInfo
     *
     * Delete calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteCalendarsUsingDELETEWithHttpInfo($authorization, $organization_id, $ids)
    {
        $returnType = 'object';
        $request = $this->deleteCalendarsUsingDELETERequest($authorization, $organization_id, $ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteCalendarsUsingDELETEAsync
     *
     * Delete calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCalendarsUsingDELETEAsync($authorization, $organization_id, $ids)
    {
        return $this->deleteCalendarsUsingDELETEAsyncWithHttpInfo($authorization, $organization_id, $ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteCalendarsUsingDELETEAsyncWithHttpInfo
     *
     * Delete calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteCalendarsUsingDELETEAsyncWithHttpInfo($authorization, $organization_id, $ids)
    {
        $returnType = 'object';
        $request = $this->deleteCalendarsUsingDELETERequest($authorization, $organization_id, $ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteCalendarsUsingDELETE'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteCalendarsUsingDELETERequest($authorization, $organization_id, $ids)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling deleteCalendarsUsingDELETE'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling deleteCalendarsUsingDELETE'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling deleteCalendarsUsingDELETE'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/calendars/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteShiftSchedulesUsingDELETE
     *
     * Delete ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function deleteShiftSchedulesUsingDELETE($authorization, $organization_id, $ids)
    {
        list($response) = $this->deleteShiftSchedulesUsingDELETEWithHttpInfo($authorization, $organization_id, $ids);
        return $response;
    }

    /**
     * Operation deleteShiftSchedulesUsingDELETEWithHttpInfo
     *
     * Delete ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteShiftSchedulesUsingDELETEWithHttpInfo($authorization, $organization_id, $ids)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->deleteShiftSchedulesUsingDELETERequest($authorization, $organization_id, $ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteShiftSchedulesUsingDELETEAsync
     *
     * Delete ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteShiftSchedulesUsingDELETEAsync($authorization, $organization_id, $ids)
    {
        return $this->deleteShiftSchedulesUsingDELETEAsyncWithHttpInfo($authorization, $organization_id, $ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteShiftSchedulesUsingDELETEAsyncWithHttpInfo
     *
     * Delete ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteShiftSchedulesUsingDELETEAsyncWithHttpInfo($authorization, $organization_id, $ids)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->deleteShiftSchedulesUsingDELETERequest($authorization, $organization_id, $ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteShiftSchedulesUsingDELETE'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteShiftSchedulesUsingDELETERequest($authorization, $organization_id, $ids)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling deleteShiftSchedulesUsingDELETE'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling deleteShiftSchedulesUsingDELETE'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling deleteShiftSchedulesUsingDELETE'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/shiftSchedules/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteShiftSubstitutionsUsingDELETE
     *
     * Delete shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function deleteShiftSubstitutionsUsingDELETE($authorization, $organization_id, $ids)
    {
        list($response) = $this->deleteShiftSubstitutionsUsingDELETEWithHttpInfo($authorization, $organization_id, $ids);
        return $response;
    }

    /**
     * Operation deleteShiftSubstitutionsUsingDELETEWithHttpInfo
     *
     * Delete shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteShiftSubstitutionsUsingDELETEWithHttpInfo($authorization, $organization_id, $ids)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->deleteShiftSubstitutionsUsingDELETERequest($authorization, $organization_id, $ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteShiftSubstitutionsUsingDELETEAsync
     *
     * Delete shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteShiftSubstitutionsUsingDELETEAsync($authorization, $organization_id, $ids)
    {
        return $this->deleteShiftSubstitutionsUsingDELETEAsyncWithHttpInfo($authorization, $organization_id, $ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteShiftSubstitutionsUsingDELETEAsyncWithHttpInfo
     *
     * Delete shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteShiftSubstitutionsUsingDELETEAsyncWithHttpInfo($authorization, $organization_id, $ids)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->deleteShiftSubstitutionsUsingDELETERequest($authorization, $organization_id, $ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteShiftSubstitutionsUsingDELETE'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteShiftSubstitutionsUsingDELETERequest($authorization, $organization_id, $ids)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling deleteShiftSubstitutionsUsingDELETE'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling deleteShiftSubstitutionsUsingDELETE'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling deleteShiftSubstitutionsUsingDELETE'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/shiftSubstitutions/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteStaffSchedulesUsingDELETE
     *
     * Delete StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function deleteStaffSchedulesUsingDELETE($authorization, $organization_id, $ids)
    {
        list($response) = $this->deleteStaffSchedulesUsingDELETEWithHttpInfo($authorization, $organization_id, $ids);
        return $response;
    }

    /**
     * Operation deleteStaffSchedulesUsingDELETEWithHttpInfo
     *
     * Delete StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteStaffSchedulesUsingDELETEWithHttpInfo($authorization, $organization_id, $ids)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->deleteStaffSchedulesUsingDELETERequest($authorization, $organization_id, $ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteStaffSchedulesUsingDELETEAsync
     *
     * Delete StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStaffSchedulesUsingDELETEAsync($authorization, $organization_id, $ids)
    {
        return $this->deleteStaffSchedulesUsingDELETEAsyncWithHttpInfo($authorization, $organization_id, $ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteStaffSchedulesUsingDELETEAsyncWithHttpInfo
     *
     * Delete StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteStaffSchedulesUsingDELETEAsyncWithHttpInfo($authorization, $organization_id, $ids)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->deleteStaffSchedulesUsingDELETERequest($authorization, $organization_id, $ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteStaffSchedulesUsingDELETE'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteStaffSchedulesUsingDELETERequest($authorization, $organization_id, $ids)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling deleteStaffSchedulesUsingDELETE'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling deleteStaffSchedulesUsingDELETE'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling deleteStaffSchedulesUsingDELETE'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/staffSchedules/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation deleteSubstitutionsUsingDELETE
     *
     * Delete scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function deleteSubstitutionsUsingDELETE($authorization, $organization_id, $ids)
    {
        list($response) = $this->deleteSubstitutionsUsingDELETEWithHttpInfo($authorization, $organization_id, $ids);
        return $response;
    }

    /**
     * Operation deleteSubstitutionsUsingDELETEWithHttpInfo
     *
     * Delete scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function deleteSubstitutionsUsingDELETEWithHttpInfo($authorization, $organization_id, $ids)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->deleteSubstitutionsUsingDELETERequest($authorization, $organization_id, $ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation deleteSubstitutionsUsingDELETEAsync
     *
     * Delete scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSubstitutionsUsingDELETEAsync($authorization, $organization_id, $ids)
    {
        return $this->deleteSubstitutionsUsingDELETEAsyncWithHttpInfo($authorization, $organization_id, $ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation deleteSubstitutionsUsingDELETEAsyncWithHttpInfo
     *
     * Delete scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function deleteSubstitutionsUsingDELETEAsyncWithHttpInfo($authorization, $organization_id, $ids)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->deleteSubstitutionsUsingDELETERequest($authorization, $organization_id, $ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'deleteSubstitutionsUsingDELETE'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to delete (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function deleteSubstitutionsUsingDELETERequest($authorization, $organization_id, $ids)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling deleteSubstitutionsUsingDELETE'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling deleteSubstitutionsUsingDELETE'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling deleteSubstitutionsUsingDELETE'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/substitutions/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'DELETE',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findCalendarUsingGET
     *
     * Get a single calendar
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function findCalendarUsingGET($authorization, $organization_id, $ids)
    {
        list($response) = $this->findCalendarUsingGETWithHttpInfo($authorization, $organization_id, $ids);
        return $response;
    }

    /**
     * Operation findCalendarUsingGETWithHttpInfo
     *
     * Get a single calendar
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function findCalendarUsingGETWithHttpInfo($authorization, $organization_id, $ids)
    {
        $returnType = 'object';
        $request = $this->findCalendarUsingGETRequest($authorization, $organization_id, $ids);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findCalendarUsingGETAsync
     *
     * Get a single calendar
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findCalendarUsingGETAsync($authorization, $organization_id, $ids)
    {
        return $this->findCalendarUsingGETAsyncWithHttpInfo($authorization, $organization_id, $ids)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findCalendarUsingGETAsyncWithHttpInfo
     *
     * Get a single calendar
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findCalendarUsingGETAsyncWithHttpInfo($authorization, $organization_id, $ids)
    {
        $returnType = 'object';
        $request = $this->findCalendarUsingGETRequest($authorization, $organization_id, $ids);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findCalendarUsingGET'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findCalendarUsingGETRequest($authorization, $organization_id, $ids)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling findCalendarUsingGET'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling findCalendarUsingGET'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling findCalendarUsingGET'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/calendars/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findShiftScheduleUsingGET
     *
     * Get a ShiftSchedule by id(s)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function findShiftScheduleUsingGET($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        list($response) = $this->findShiftScheduleUsingGETWithHttpInfo($authorization, $organization_id, $ids, $fields, $include);
        return $response;
    }

    /**
     * Operation findShiftScheduleUsingGETWithHttpInfo
     *
     * Get a ShiftSchedule by id(s)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function findShiftScheduleUsingGETWithHttpInfo($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->findShiftScheduleUsingGETRequest($authorization, $organization_id, $ids, $fields, $include);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findShiftScheduleUsingGETAsync
     *
     * Get a ShiftSchedule by id(s)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findShiftScheduleUsingGETAsync($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        return $this->findShiftScheduleUsingGETAsyncWithHttpInfo($authorization, $organization_id, $ids, $fields, $include)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findShiftScheduleUsingGETAsyncWithHttpInfo
     *
     * Get a ShiftSchedule by id(s)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findShiftScheduleUsingGETAsyncWithHttpInfo($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->findShiftScheduleUsingGETRequest($authorization, $organization_id, $ids, $fields, $include);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findShiftScheduleUsingGET'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findShiftScheduleUsingGETRequest($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling findShiftScheduleUsingGET'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling findShiftScheduleUsingGET'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling findShiftScheduleUsingGET'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/shiftSchedules/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findShiftSubstitutionUsingGET
     *
     * Get one or more shift substitutions by id (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function findShiftSubstitutionUsingGET($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        list($response) = $this->findShiftSubstitutionUsingGETWithHttpInfo($authorization, $organization_id, $ids, $fields, $include);
        return $response;
    }

    /**
     * Operation findShiftSubstitutionUsingGETWithHttpInfo
     *
     * Get one or more shift substitutions by id (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function findShiftSubstitutionUsingGETWithHttpInfo($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->findShiftSubstitutionUsingGETRequest($authorization, $organization_id, $ids, $fields, $include);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findShiftSubstitutionUsingGETAsync
     *
     * Get one or more shift substitutions by id (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findShiftSubstitutionUsingGETAsync($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        return $this->findShiftSubstitutionUsingGETAsyncWithHttpInfo($authorization, $organization_id, $ids, $fields, $include)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findShiftSubstitutionUsingGETAsyncWithHttpInfo
     *
     * Get one or more shift substitutions by id (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findShiftSubstitutionUsingGETAsyncWithHttpInfo($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->findShiftSubstitutionUsingGETRequest($authorization, $organization_id, $ids, $fields, $include);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findShiftSubstitutionUsingGET'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findShiftSubstitutionUsingGETRequest($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling findShiftSubstitutionUsingGET'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling findShiftSubstitutionUsingGET'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling findShiftSubstitutionUsingGET'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/shiftSubstitutions/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findStaffScheduleUsingGET
     *
     * Get a StaffSchedule by id(s)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function findStaffScheduleUsingGET($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        list($response) = $this->findStaffScheduleUsingGETWithHttpInfo($authorization, $organization_id, $ids, $fields, $include);
        return $response;
    }

    /**
     * Operation findStaffScheduleUsingGETWithHttpInfo
     *
     * Get a StaffSchedule by id(s)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function findStaffScheduleUsingGETWithHttpInfo($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->findStaffScheduleUsingGETRequest($authorization, $organization_id, $ids, $fields, $include);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findStaffScheduleUsingGETAsync
     *
     * Get a StaffSchedule by id(s)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findStaffScheduleUsingGETAsync($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        return $this->findStaffScheduleUsingGETAsyncWithHttpInfo($authorization, $organization_id, $ids, $fields, $include)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findStaffScheduleUsingGETAsyncWithHttpInfo
     *
     * Get a StaffSchedule by id(s)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findStaffScheduleUsingGETAsyncWithHttpInfo($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->findStaffScheduleUsingGETRequest($authorization, $organization_id, $ids, $fields, $include);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findStaffScheduleUsingGET'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findStaffScheduleUsingGETRequest($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling findStaffScheduleUsingGET'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling findStaffScheduleUsingGET'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling findStaffScheduleUsingGET'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/staffSchedules/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation findSubstitutionUsingGET
     *
     * Get a single substitution(s) (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function findSubstitutionUsingGET($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        list($response) = $this->findSubstitutionUsingGETWithHttpInfo($authorization, $organization_id, $ids, $fields, $include);
        return $response;
    }

    /**
     * Operation findSubstitutionUsingGETWithHttpInfo
     *
     * Get a single substitution(s) (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function findSubstitutionUsingGETWithHttpInfo($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->findSubstitutionUsingGETRequest($authorization, $organization_id, $ids, $fields, $include);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation findSubstitutionUsingGETAsync
     *
     * Get a single substitution(s) (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findSubstitutionUsingGETAsync($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        return $this->findSubstitutionUsingGETAsyncWithHttpInfo($authorization, $organization_id, $ids, $fields, $include)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation findSubstitutionUsingGETAsyncWithHttpInfo
     *
     * Get a single substitution(s) (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function findSubstitutionUsingGETAsyncWithHttpInfo($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->findSubstitutionUsingGETRequest($authorization, $organization_id, $ids, $fields, $include);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'findSubstitutionUsingGET'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to find (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function findSubstitutionUsingGETRequest($authorization, $organization_id, $ids, $fields = null, $include = null)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling findSubstitutionUsingGET'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling findSubstitutionUsingGET'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling findSubstitutionUsingGET'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/substitutions/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listAuditsUsingGET
     *
     * List scheduling audits
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields Fields to be included in the response. (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt;&lt;p&gt; Ex. filter[calendarId]&#x3D;1234567890, filter[action]&#x3D;CREATE, filter[auditResource.type]&#x3D;calendar, etc.&lt;/p&gt; (optional)
     * @param  int[] $calendar_id One or more calendarIds that this request should filter by. (optional)
     * @param  int[] $shift_schedule_id One or more shiftScheduleIds that this request should filter by. (optional)
     * @param  int[] $staff_schedule_id One or more staffScheduleIds that this request should filter by. (optional)
     * @param  int[] $staff_substitution_id One or more staffSubstitutionIds (unavailability/replacement) that this request should filter by. (optional)
     * @param  int[] $shift_schedule_substitution_id One or more shiftScheduleSubstitutionIds (override) that this request should filter by. (optional)
     * @param  string $action Audit CRUD action type that this request should filter by. (optional)
     * @param  string $created_date_gte &lt;p&gt;Start date (in UTC +0) of the audits that this request should filter by.&lt;/p&gt;&lt;p&gt; Ex. 2019-01-08 or 2019-01-08T00:00:00Z (optional)
     * @param  string $created_date_lte &lt;p&gt;End date (in UTC +0) of the audits that this request should filter by.&lt;/p&gt;&lt;p&gt; Ex. 2019-01-09 or 2019-01-09T00:00:00Z (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction.&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;action,-createdDate sorts by the action ascending and createdDate descending.&lt;/p&gt;&lt;p&gt; Audit records are by default sorted by the createdDate descending.&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\SchedulingAudit
     */
    public function listAuditsUsingGET($authorization, $organization_id, $fields = null, $filter = null, $calendar_id = null, $shift_schedule_id = null, $staff_schedule_id = null, $staff_substitution_id = null, $shift_schedule_substitution_id = null, $action = null, $created_date_gte = null, $created_date_lte = null, $sort = null, $page_size = null, $page_no = null)
    {
        list($response) = $this->listAuditsUsingGETWithHttpInfo($authorization, $organization_id, $fields, $filter, $calendar_id, $shift_schedule_id, $staff_schedule_id, $staff_substitution_id, $shift_schedule_substitution_id, $action, $created_date_gte, $created_date_lte, $sort, $page_size, $page_no);
        return $response;
    }

    /**
     * Operation listAuditsUsingGETWithHttpInfo
     *
     * List scheduling audits
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields Fields to be included in the response. (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt;&lt;p&gt; Ex. filter[calendarId]&#x3D;1234567890, filter[action]&#x3D;CREATE, filter[auditResource.type]&#x3D;calendar, etc.&lt;/p&gt; (optional)
     * @param  int[] $calendar_id One or more calendarIds that this request should filter by. (optional)
     * @param  int[] $shift_schedule_id One or more shiftScheduleIds that this request should filter by. (optional)
     * @param  int[] $staff_schedule_id One or more staffScheduleIds that this request should filter by. (optional)
     * @param  int[] $staff_substitution_id One or more staffSubstitutionIds (unavailability/replacement) that this request should filter by. (optional)
     * @param  int[] $shift_schedule_substitution_id One or more shiftScheduleSubstitutionIds (override) that this request should filter by. (optional)
     * @param  string $action Audit CRUD action type that this request should filter by. (optional)
     * @param  string $created_date_gte &lt;p&gt;Start date (in UTC +0) of the audits that this request should filter by.&lt;/p&gt;&lt;p&gt; Ex. 2019-01-08 or 2019-01-08T00:00:00Z (optional)
     * @param  string $created_date_lte &lt;p&gt;End date (in UTC +0) of the audits that this request should filter by.&lt;/p&gt;&lt;p&gt; Ex. 2019-01-09 or 2019-01-09T00:00:00Z (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction.&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;action,-createdDate sorts by the action ascending and createdDate descending.&lt;/p&gt;&lt;p&gt; Audit records are by default sorted by the createdDate descending.&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\SchedulingAudit, HTTP status code, HTTP response headers (array of strings)
     */
    public function listAuditsUsingGETWithHttpInfo($authorization, $organization_id, $fields = null, $filter = null, $calendar_id = null, $shift_schedule_id = null, $staff_schedule_id = null, $staff_substitution_id = null, $shift_schedule_substitution_id = null, $action = null, $created_date_gte = null, $created_date_lte = null, $sort = null, $page_size = null, $page_no = null)
    {
        $returnType = '\Swagger\Client\Model\SchedulingAudit';
        $request = $this->listAuditsUsingGETRequest($authorization, $organization_id, $fields, $filter, $calendar_id, $shift_schedule_id, $staff_schedule_id, $staff_substitution_id, $shift_schedule_substitution_id, $action, $created_date_gte, $created_date_lte, $sort, $page_size, $page_no);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\SchedulingAudit',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listAuditsUsingGETAsync
     *
     * List scheduling audits
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields Fields to be included in the response. (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt;&lt;p&gt; Ex. filter[calendarId]&#x3D;1234567890, filter[action]&#x3D;CREATE, filter[auditResource.type]&#x3D;calendar, etc.&lt;/p&gt; (optional)
     * @param  int[] $calendar_id One or more calendarIds that this request should filter by. (optional)
     * @param  int[] $shift_schedule_id One or more shiftScheduleIds that this request should filter by. (optional)
     * @param  int[] $staff_schedule_id One or more staffScheduleIds that this request should filter by. (optional)
     * @param  int[] $staff_substitution_id One or more staffSubstitutionIds (unavailability/replacement) that this request should filter by. (optional)
     * @param  int[] $shift_schedule_substitution_id One or more shiftScheduleSubstitutionIds (override) that this request should filter by. (optional)
     * @param  string $action Audit CRUD action type that this request should filter by. (optional)
     * @param  string $created_date_gte &lt;p&gt;Start date (in UTC +0) of the audits that this request should filter by.&lt;/p&gt;&lt;p&gt; Ex. 2019-01-08 or 2019-01-08T00:00:00Z (optional)
     * @param  string $created_date_lte &lt;p&gt;End date (in UTC +0) of the audits that this request should filter by.&lt;/p&gt;&lt;p&gt; Ex. 2019-01-09 or 2019-01-09T00:00:00Z (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction.&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;action,-createdDate sorts by the action ascending and createdDate descending.&lt;/p&gt;&lt;p&gt; Audit records are by default sorted by the createdDate descending.&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAuditsUsingGETAsync($authorization, $organization_id, $fields = null, $filter = null, $calendar_id = null, $shift_schedule_id = null, $staff_schedule_id = null, $staff_substitution_id = null, $shift_schedule_substitution_id = null, $action = null, $created_date_gte = null, $created_date_lte = null, $sort = null, $page_size = null, $page_no = null)
    {
        return $this->listAuditsUsingGETAsyncWithHttpInfo($authorization, $organization_id, $fields, $filter, $calendar_id, $shift_schedule_id, $staff_schedule_id, $staff_substitution_id, $shift_schedule_substitution_id, $action, $created_date_gte, $created_date_lte, $sort, $page_size, $page_no)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listAuditsUsingGETAsyncWithHttpInfo
     *
     * List scheduling audits
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields Fields to be included in the response. (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt;&lt;p&gt; Ex. filter[calendarId]&#x3D;1234567890, filter[action]&#x3D;CREATE, filter[auditResource.type]&#x3D;calendar, etc.&lt;/p&gt; (optional)
     * @param  int[] $calendar_id One or more calendarIds that this request should filter by. (optional)
     * @param  int[] $shift_schedule_id One or more shiftScheduleIds that this request should filter by. (optional)
     * @param  int[] $staff_schedule_id One or more staffScheduleIds that this request should filter by. (optional)
     * @param  int[] $staff_substitution_id One or more staffSubstitutionIds (unavailability/replacement) that this request should filter by. (optional)
     * @param  int[] $shift_schedule_substitution_id One or more shiftScheduleSubstitutionIds (override) that this request should filter by. (optional)
     * @param  string $action Audit CRUD action type that this request should filter by. (optional)
     * @param  string $created_date_gte &lt;p&gt;Start date (in UTC +0) of the audits that this request should filter by.&lt;/p&gt;&lt;p&gt; Ex. 2019-01-08 or 2019-01-08T00:00:00Z (optional)
     * @param  string $created_date_lte &lt;p&gt;End date (in UTC +0) of the audits that this request should filter by.&lt;/p&gt;&lt;p&gt; Ex. 2019-01-09 or 2019-01-09T00:00:00Z (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction.&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;action,-createdDate sorts by the action ascending and createdDate descending.&lt;/p&gt;&lt;p&gt; Audit records are by default sorted by the createdDate descending.&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listAuditsUsingGETAsyncWithHttpInfo($authorization, $organization_id, $fields = null, $filter = null, $calendar_id = null, $shift_schedule_id = null, $staff_schedule_id = null, $staff_substitution_id = null, $shift_schedule_substitution_id = null, $action = null, $created_date_gte = null, $created_date_lte = null, $sort = null, $page_size = null, $page_no = null)
    {
        $returnType = '\Swagger\Client\Model\SchedulingAudit';
        $request = $this->listAuditsUsingGETRequest($authorization, $organization_id, $fields, $filter, $calendar_id, $shift_schedule_id, $staff_schedule_id, $staff_substitution_id, $shift_schedule_substitution_id, $action, $created_date_gte, $created_date_lte, $sort, $page_size, $page_no);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listAuditsUsingGET'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields Fields to be included in the response. (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt;&lt;p&gt; Ex. filter[calendarId]&#x3D;1234567890, filter[action]&#x3D;CREATE, filter[auditResource.type]&#x3D;calendar, etc.&lt;/p&gt; (optional)
     * @param  int[] $calendar_id One or more calendarIds that this request should filter by. (optional)
     * @param  int[] $shift_schedule_id One or more shiftScheduleIds that this request should filter by. (optional)
     * @param  int[] $staff_schedule_id One or more staffScheduleIds that this request should filter by. (optional)
     * @param  int[] $staff_substitution_id One or more staffSubstitutionIds (unavailability/replacement) that this request should filter by. (optional)
     * @param  int[] $shift_schedule_substitution_id One or more shiftScheduleSubstitutionIds (override) that this request should filter by. (optional)
     * @param  string $action Audit CRUD action type that this request should filter by. (optional)
     * @param  string $created_date_gte &lt;p&gt;Start date (in UTC +0) of the audits that this request should filter by.&lt;/p&gt;&lt;p&gt; Ex. 2019-01-08 or 2019-01-08T00:00:00Z (optional)
     * @param  string $created_date_lte &lt;p&gt;End date (in UTC +0) of the audits that this request should filter by.&lt;/p&gt;&lt;p&gt; Ex. 2019-01-09 or 2019-01-09T00:00:00Z (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction.&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;action,-createdDate sorts by the action ascending and createdDate descending.&lt;/p&gt;&lt;p&gt; Audit records are by default sorted by the createdDate descending.&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listAuditsUsingGETRequest($authorization, $organization_id, $fields = null, $filter = null, $calendar_id = null, $shift_schedule_id = null, $staff_schedule_id = null, $staff_substitution_id = null, $shift_schedule_substitution_id = null, $action = null, $created_date_gte = null, $created_date_lte = null, $sort = null, $page_size = null, $page_no = null)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling listAuditsUsingGET'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling listAuditsUsingGET'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/audits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if (is_array($calendar_id)) {
            $queryParams['calendarId'] = $calendar_id;
        } else
        if ($calendar_id !== null) {
            $queryParams['calendarId'] = ObjectSerializer::toQueryValue($calendar_id);
        }
        // query params
        if (is_array($shift_schedule_id)) {
            $queryParams['shiftScheduleId'] = $shift_schedule_id;
        } else
        if ($shift_schedule_id !== null) {
            $queryParams['shiftScheduleId'] = ObjectSerializer::toQueryValue($shift_schedule_id);
        }
        // query params
        if (is_array($staff_schedule_id)) {
            $queryParams['staffScheduleId'] = $staff_schedule_id;
        } else
        if ($staff_schedule_id !== null) {
            $queryParams['staffScheduleId'] = ObjectSerializer::toQueryValue($staff_schedule_id);
        }
        // query params
        if (is_array($staff_substitution_id)) {
            $queryParams['staffSubstitutionId'] = $staff_substitution_id;
        } else
        if ($staff_substitution_id !== null) {
            $queryParams['staffSubstitutionId'] = ObjectSerializer::toQueryValue($staff_substitution_id);
        }
        // query params
        if (is_array($shift_schedule_substitution_id)) {
            $queryParams['shiftScheduleSubstitutionId'] = $shift_schedule_substitution_id;
        } else
        if ($shift_schedule_substitution_id !== null) {
            $queryParams['shiftScheduleSubstitutionId'] = ObjectSerializer::toQueryValue($shift_schedule_substitution_id);
        }
        // query params
        if ($action !== null) {
            $queryParams['action'] = ObjectSerializer::toQueryValue($action);
        }
        // query params
        if ($created_date_gte !== null) {
            $queryParams['createdDate[gte]'] = ObjectSerializer::toQueryValue($created_date_gte);
        }
        // query params
        if ($created_date_lte !== null) {
            $queryParams['createdDate[lte]'] = ObjectSerializer::toQueryValue($created_date_lte);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($page_no !== null) {
            $queryParams['pageNo'] = ObjectSerializer::toQueryValue($page_no);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCalendarEventsUsingGET
     *
     * List of events and their corresponding assignments
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $start Start date/time to fetch events from. (optional)
     * @param  string $end End date/time of the interval to fetch events from. (optional)
     * @param  string $instant Instant to fetch events for. (optional)
     * @param  int $days Number of days to fetch events for. (optional)
     * @param  string $calendar_id IDs for calendars that this request should filter by. (optional)
     * @param  string $shift_schedule_id IDs for shifts that this request should filter by. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\FlatCalendarEvent
     */
    public function listCalendarEventsUsingGET($authorization, $organization_id, $fields = null, $include = null, $start = null, $end = null, $instant = null, $days = null, $calendar_id = null, $shift_schedule_id = null)
    {
        list($response) = $this->listCalendarEventsUsingGETWithHttpInfo($authorization, $organization_id, $fields, $include, $start, $end, $instant, $days, $calendar_id, $shift_schedule_id);
        return $response;
    }

    /**
     * Operation listCalendarEventsUsingGETWithHttpInfo
     *
     * List of events and their corresponding assignments
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $start Start date/time to fetch events from. (optional)
     * @param  string $end End date/time of the interval to fetch events from. (optional)
     * @param  string $instant Instant to fetch events for. (optional)
     * @param  int $days Number of days to fetch events for. (optional)
     * @param  string $calendar_id IDs for calendars that this request should filter by. (optional)
     * @param  string $shift_schedule_id IDs for shifts that this request should filter by. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\FlatCalendarEvent, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCalendarEventsUsingGETWithHttpInfo($authorization, $organization_id, $fields = null, $include = null, $start = null, $end = null, $instant = null, $days = null, $calendar_id = null, $shift_schedule_id = null)
    {
        $returnType = '\Swagger\Client\Model\FlatCalendarEvent';
        $request = $this->listCalendarEventsUsingGETRequest($authorization, $organization_id, $fields, $include, $start, $end, $instant, $days, $calendar_id, $shift_schedule_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\FlatCalendarEvent',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCalendarEventsUsingGETAsync
     *
     * List of events and their corresponding assignments
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $start Start date/time to fetch events from. (optional)
     * @param  string $end End date/time of the interval to fetch events from. (optional)
     * @param  string $instant Instant to fetch events for. (optional)
     * @param  int $days Number of days to fetch events for. (optional)
     * @param  string $calendar_id IDs for calendars that this request should filter by. (optional)
     * @param  string $shift_schedule_id IDs for shifts that this request should filter by. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCalendarEventsUsingGETAsync($authorization, $organization_id, $fields = null, $include = null, $start = null, $end = null, $instant = null, $days = null, $calendar_id = null, $shift_schedule_id = null)
    {
        return $this->listCalendarEventsUsingGETAsyncWithHttpInfo($authorization, $organization_id, $fields, $include, $start, $end, $instant, $days, $calendar_id, $shift_schedule_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCalendarEventsUsingGETAsyncWithHttpInfo
     *
     * List of events and their corresponding assignments
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $start Start date/time to fetch events from. (optional)
     * @param  string $end End date/time of the interval to fetch events from. (optional)
     * @param  string $instant Instant to fetch events for. (optional)
     * @param  int $days Number of days to fetch events for. (optional)
     * @param  string $calendar_id IDs for calendars that this request should filter by. (optional)
     * @param  string $shift_schedule_id IDs for shifts that this request should filter by. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCalendarEventsUsingGETAsyncWithHttpInfo($authorization, $organization_id, $fields = null, $include = null, $start = null, $end = null, $instant = null, $days = null, $calendar_id = null, $shift_schedule_id = null)
    {
        $returnType = '\Swagger\Client\Model\FlatCalendarEvent';
        $request = $this->listCalendarEventsUsingGETRequest($authorization, $organization_id, $fields, $include, $start, $end, $instant, $days, $calendar_id, $shift_schedule_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCalendarEventsUsingGET'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $start Start date/time to fetch events from. (optional)
     * @param  string $end End date/time of the interval to fetch events from. (optional)
     * @param  string $instant Instant to fetch events for. (optional)
     * @param  int $days Number of days to fetch events for. (optional)
     * @param  string $calendar_id IDs for calendars that this request should filter by. (optional)
     * @param  string $shift_schedule_id IDs for shifts that this request should filter by. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCalendarEventsUsingGETRequest($authorization, $organization_id, $fields = null, $include = null, $start = null, $end = null, $instant = null, $days = null, $calendar_id = null, $shift_schedule_id = null)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling listCalendarEventsUsingGET'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling listCalendarEventsUsingGET'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/calendarEvents';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include);
        }
        // query params
        if ($start !== null) {
            $queryParams['start'] = ObjectSerializer::toQueryValue($start);
        }
        // query params
        if ($end !== null) {
            $queryParams['end'] = ObjectSerializer::toQueryValue($end);
        }
        // query params
        if ($instant !== null) {
            $queryParams['instant'] = ObjectSerializer::toQueryValue($instant);
        }
        // query params
        if ($days !== null) {
            $queryParams['days'] = ObjectSerializer::toQueryValue($days);
        }
        // query params
        if ($calendar_id !== null) {
            $queryParams['calendarId'] = ObjectSerializer::toQueryValue($calendar_id);
        }
        // query params
        if ($shift_schedule_id !== null) {
            $queryParams['shiftScheduleId'] = ObjectSerializer::toQueryValue($shift_schedule_id);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listCalendarsUsingGET
     *
     * List calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function listCalendarsUsingGET($authorization, $organization_id)
    {
        list($response) = $this->listCalendarsUsingGETWithHttpInfo($authorization, $organization_id);
        return $response;
    }

    /**
     * Operation listCalendarsUsingGETWithHttpInfo
     *
     * List calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function listCalendarsUsingGETWithHttpInfo($authorization, $organization_id)
    {
        $returnType = 'object';
        $request = $this->listCalendarsUsingGETRequest($authorization, $organization_id);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listCalendarsUsingGETAsync
     *
     * List calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCalendarsUsingGETAsync($authorization, $organization_id)
    {
        return $this->listCalendarsUsingGETAsyncWithHttpInfo($authorization, $organization_id)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listCalendarsUsingGETAsyncWithHttpInfo
     *
     * List calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listCalendarsUsingGETAsyncWithHttpInfo($authorization, $organization_id)
    {
        $returnType = 'object';
        $request = $this->listCalendarsUsingGETRequest($authorization, $organization_id);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listCalendarsUsingGET'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listCalendarsUsingGETRequest($authorization, $organization_id)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling listCalendarsUsingGET'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling listCalendarsUsingGET'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/calendars';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listShiftSchedulesUsingGET
     *
     * List ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function listShiftSchedulesUsingGET($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        list($response) = $this->listShiftSchedulesUsingGETWithHttpInfo($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no);
        return $response;
    }

    /**
     * Operation listShiftSchedulesUsingGETWithHttpInfo
     *
     * List ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function listShiftSchedulesUsingGETWithHttpInfo($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->listShiftSchedulesUsingGETRequest($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listShiftSchedulesUsingGETAsync
     *
     * List ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listShiftSchedulesUsingGETAsync($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        return $this->listShiftSchedulesUsingGETAsyncWithHttpInfo($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listShiftSchedulesUsingGETAsyncWithHttpInfo
     *
     * List ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listShiftSchedulesUsingGETAsyncWithHttpInfo($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->listShiftSchedulesUsingGETRequest($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listShiftSchedulesUsingGET'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listShiftSchedulesUsingGETRequest($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling listShiftSchedulesUsingGET'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling listShiftSchedulesUsingGET'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/shiftSchedules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($page_no !== null) {
            $queryParams['pageNo'] = ObjectSerializer::toQueryValue($page_no);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listShiftSubstitutionsUsingGET
     *
     * List shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function listShiftSubstitutionsUsingGET($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        list($response) = $this->listShiftSubstitutionsUsingGETWithHttpInfo($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no);
        return $response;
    }

    /**
     * Operation listShiftSubstitutionsUsingGETWithHttpInfo
     *
     * List shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function listShiftSubstitutionsUsingGETWithHttpInfo($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->listShiftSubstitutionsUsingGETRequest($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listShiftSubstitutionsUsingGETAsync
     *
     * List shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listShiftSubstitutionsUsingGETAsync($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        return $this->listShiftSubstitutionsUsingGETAsyncWithHttpInfo($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listShiftSubstitutionsUsingGETAsyncWithHttpInfo
     *
     * List shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listShiftSubstitutionsUsingGETAsyncWithHttpInfo($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->listShiftSubstitutionsUsingGETRequest($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listShiftSubstitutionsUsingGET'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listShiftSubstitutionsUsingGETRequest($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling listShiftSubstitutionsUsingGET'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling listShiftSubstitutionsUsingGET'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/shiftSubstitutions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($page_no !== null) {
            $queryParams['pageNo'] = ObjectSerializer::toQueryValue($page_no);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listStaffSchedulesUsingGET
     *
     * List StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function listStaffSchedulesUsingGET($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        list($response) = $this->listStaffSchedulesUsingGETWithHttpInfo($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no);
        return $response;
    }

    /**
     * Operation listStaffSchedulesUsingGETWithHttpInfo
     *
     * List StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function listStaffSchedulesUsingGETWithHttpInfo($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->listStaffSchedulesUsingGETRequest($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listStaffSchedulesUsingGETAsync
     *
     * List StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStaffSchedulesUsingGETAsync($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        return $this->listStaffSchedulesUsingGETAsyncWithHttpInfo($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listStaffSchedulesUsingGETAsyncWithHttpInfo
     *
     * List StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listStaffSchedulesUsingGETAsyncWithHttpInfo($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->listStaffSchedulesUsingGETRequest($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listStaffSchedulesUsingGET'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listStaffSchedulesUsingGETRequest($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling listStaffSchedulesUsingGET'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling listStaffSchedulesUsingGET'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/staffSchedules';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($page_no !== null) {
            $queryParams['pageNo'] = ObjectSerializer::toQueryValue($page_no);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listSubstitutionsUsingGET
     *
     * List scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function listSubstitutionsUsingGET($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        list($response) = $this->listSubstitutionsUsingGETWithHttpInfo($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no);
        return $response;
    }

    /**
     * Operation listSubstitutionsUsingGETWithHttpInfo
     *
     * List scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function listSubstitutionsUsingGETWithHttpInfo($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->listSubstitutionsUsingGETRequest($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation listSubstitutionsUsingGETAsync
     *
     * List scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSubstitutionsUsingGETAsync($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        return $this->listSubstitutionsUsingGETAsyncWithHttpInfo($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listSubstitutionsUsingGETAsyncWithHttpInfo
     *
     * List scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listSubstitutionsUsingGETAsyncWithHttpInfo($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->listSubstitutionsUsingGETRequest($authorization, $organization_id, $fields, $include, $filter, $sort, $page_size, $page_no);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listSubstitutionsUsingGET'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $fields &lt;p&gt;fields to be included in the response.&lt;/p&gt;&lt;p&gt;fields[resourceName] may be used to specify fields returned for included documents. When doing so, it is not necessary to also request to include the resource as the include is implied by the fields request&lt;/p&gt; (optional)
     * @param  string $include &lt;p&gt;Specifying the includes parameter will result in a compound document response, adding resources to included which have been referenced by resources returned in data.&lt;p&gt;&lt;p&gt;include may be specified as a comma delimited list of resource names.&lt;/p&gt; (optional)
     * @param  string $filter &lt;p&gt;filter may be used to specify filter criteria for the request.&lt;/p&gt;&lt;p&gt;filters are specified in the format of filter[fieldName], where fieldName is any field supported by this resource.&lt;/p&gt;&lt;p&gt;multiple filter criteria will result in AND conditions, with the exception of multiple filters on the same field, in which case the criteria will be treated as an OR condition&lt;/p&gt; (optional)
     * @param  string $sort &lt;p&gt;Comma delimited list of fields to sort by.&lt;/p&gt;&lt;p&gt; +/- can precede the field name to indicate direction (ascending/descending).&lt;/p&gt;&lt;p&gt; + is the default direction&lt;/p&gt;&lt;p&gt; Ex. sort&#x3D;status,-createdDate sorts by status ascending and createdDate descending&lt;/p&gt; (optional)
     * @param  int $page_size The number of records per page to be included in the response (optional)
     * @param  int $page_no The page to be returned. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function listSubstitutionsUsingGETRequest($authorization, $organization_id, $fields = null, $include = null, $filter = null, $sort = null, $page_size = null, $page_no = null)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling listSubstitutionsUsingGET'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling listSubstitutionsUsingGET'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/substitutions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($fields !== null) {
            $queryParams['fields'] = ObjectSerializer::toQueryValue($fields);
        }
        // query params
        if ($include !== null) {
            $queryParams['include'] = ObjectSerializer::toQueryValue($include);
        }
        // query params
        if ($filter !== null) {
            $queryParams['filter'] = ObjectSerializer::toQueryValue($filter);
        }
        // query params
        if ($sort !== null) {
            $queryParams['sort'] = ObjectSerializer::toQueryValue($sort);
        }
        // query params
        if ($page_size !== null) {
            $queryParams['pageSize'] = ObjectSerializer::toQueryValue($page_size);
        }
        // query params
        if ($page_no !== null) {
            $queryParams['pageNo'] = ObjectSerializer::toQueryValue($page_no);
        }
        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateCalendarsUsingPUT
     *
     * Update calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A calendars object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return object
     */
    public function updateCalendarsUsingPUT($authorization, $organization_id, $ids, $data)
    {
        list($response) = $this->updateCalendarsUsingPUTWithHttpInfo($authorization, $organization_id, $ids, $data);
        return $response;
    }

    /**
     * Operation updateCalendarsUsingPUTWithHttpInfo
     *
     * Update calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A calendars object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of object, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateCalendarsUsingPUTWithHttpInfo($authorization, $organization_id, $ids, $data)
    {
        $returnType = 'object';
        $request = $this->updateCalendarsUsingPUTRequest($authorization, $organization_id, $ids, $data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateCalendarsUsingPUTAsync
     *
     * Update calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A calendars object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCalendarsUsingPUTAsync($authorization, $organization_id, $ids, $data)
    {
        return $this->updateCalendarsUsingPUTAsyncWithHttpInfo($authorization, $organization_id, $ids, $data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateCalendarsUsingPUTAsyncWithHttpInfo
     *
     * Update calendars
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A calendars object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateCalendarsUsingPUTAsyncWithHttpInfo($authorization, $organization_id, $ids, $data)
    {
        $returnType = 'object';
        $request = $this->updateCalendarsUsingPUTRequest($authorization, $organization_id, $ids, $data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateCalendarsUsingPUT'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A calendars object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateCalendarsUsingPUTRequest($authorization, $organization_id, $ids, $data)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling updateCalendarsUsingPUT'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling updateCalendarsUsingPUT'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling updateCalendarsUsingPUT'
            );
        }
        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling updateCalendarsUsingPUT'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/calendars/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateShiftSchedulesUsingPUT
     *
     * Update ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A ShiftSchedule object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function updateShiftSchedulesUsingPUT($authorization, $organization_id, $ids, $data)
    {
        list($response) = $this->updateShiftSchedulesUsingPUTWithHttpInfo($authorization, $organization_id, $ids, $data);
        return $response;
    }

    /**
     * Operation updateShiftSchedulesUsingPUTWithHttpInfo
     *
     * Update ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A ShiftSchedule object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateShiftSchedulesUsingPUTWithHttpInfo($authorization, $organization_id, $ids, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->updateShiftSchedulesUsingPUTRequest($authorization, $organization_id, $ids, $data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateShiftSchedulesUsingPUTAsync
     *
     * Update ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A ShiftSchedule object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateShiftSchedulesUsingPUTAsync($authorization, $organization_id, $ids, $data)
    {
        return $this->updateShiftSchedulesUsingPUTAsyncWithHttpInfo($authorization, $organization_id, $ids, $data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateShiftSchedulesUsingPUTAsyncWithHttpInfo
     *
     * Update ShiftSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A ShiftSchedule object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateShiftSchedulesUsingPUTAsyncWithHttpInfo($authorization, $organization_id, $ids, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->updateShiftSchedulesUsingPUTRequest($authorization, $organization_id, $ids, $data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateShiftSchedulesUsingPUT'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A ShiftSchedule object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateShiftSchedulesUsingPUTRequest($authorization, $organization_id, $ids, $data)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling updateShiftSchedulesUsingPUT'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling updateShiftSchedulesUsingPUT'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling updateShiftSchedulesUsingPUT'
            );
        }
        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling updateShiftSchedulesUsingPUT'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/shiftSchedules/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateShiftSubstitutionsUsingPUT
     *
     * Update shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function updateShiftSubstitutionsUsingPUT($authorization, $organization_id, $ids, $data)
    {
        list($response) = $this->updateShiftSubstitutionsUsingPUTWithHttpInfo($authorization, $organization_id, $ids, $data);
        return $response;
    }

    /**
     * Operation updateShiftSubstitutionsUsingPUTWithHttpInfo
     *
     * Update shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateShiftSubstitutionsUsingPUTWithHttpInfo($authorization, $organization_id, $ids, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->updateShiftSubstitutionsUsingPUTRequest($authorization, $organization_id, $ids, $data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateShiftSubstitutionsUsingPUTAsync
     *
     * Update shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateShiftSubstitutionsUsingPUTAsync($authorization, $organization_id, $ids, $data)
    {
        return $this->updateShiftSubstitutionsUsingPUTAsyncWithHttpInfo($authorization, $organization_id, $ids, $data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateShiftSubstitutionsUsingPUTAsyncWithHttpInfo
     *
     * Update shift substitutions (Override)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateShiftSubstitutionsUsingPUTAsyncWithHttpInfo($authorization, $organization_id, $ids, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->updateShiftSubstitutionsUsingPUTRequest($authorization, $organization_id, $ids, $data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateShiftSubstitutionsUsingPUT'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateShiftSubstitutionsUsingPUTRequest($authorization, $organization_id, $ids, $data)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling updateShiftSubstitutionsUsingPUT'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling updateShiftSubstitutionsUsingPUT'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling updateShiftSubstitutionsUsingPUT'
            );
        }
        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling updateShiftSubstitutionsUsingPUT'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/shiftSubstitutions/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateStaffSchedulesUsingPUT
     *
     * Update StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A StaffSchedule object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function updateStaffSchedulesUsingPUT($authorization, $organization_id, $ids, $data)
    {
        list($response) = $this->updateStaffSchedulesUsingPUTWithHttpInfo($authorization, $organization_id, $ids, $data);
        return $response;
    }

    /**
     * Operation updateStaffSchedulesUsingPUTWithHttpInfo
     *
     * Update StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A StaffSchedule object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateStaffSchedulesUsingPUTWithHttpInfo($authorization, $organization_id, $ids, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->updateStaffSchedulesUsingPUTRequest($authorization, $organization_id, $ids, $data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateStaffSchedulesUsingPUTAsync
     *
     * Update StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A StaffSchedule object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStaffSchedulesUsingPUTAsync($authorization, $organization_id, $ids, $data)
    {
        return $this->updateStaffSchedulesUsingPUTAsyncWithHttpInfo($authorization, $organization_id, $ids, $data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateStaffSchedulesUsingPUTAsyncWithHttpInfo
     *
     * Update StaffSchedules
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A StaffSchedule object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateStaffSchedulesUsingPUTAsyncWithHttpInfo($authorization, $organization_id, $ids, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->updateStaffSchedulesUsingPUTRequest($authorization, $organization_id, $ids, $data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateStaffSchedulesUsingPUT'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A StaffSchedule object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateStaffSchedulesUsingPUTRequest($authorization, $organization_id, $ids, $data)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling updateStaffSchedulesUsingPUT'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling updateStaffSchedulesUsingPUT'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling updateStaffSchedulesUsingPUT'
            );
        }
        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling updateStaffSchedulesUsingPUT'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/staffSchedules/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation updateSubstitutionsUsingPUT
     *
     * Update scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Swagger\Client\Model\ResponseDocument
     */
    public function updateSubstitutionsUsingPUT($authorization, $organization_id, $ids, $data)
    {
        list($response) = $this->updateSubstitutionsUsingPUTWithHttpInfo($authorization, $organization_id, $ids, $data);
        return $response;
    }

    /**
     * Operation updateSubstitutionsUsingPUTWithHttpInfo
     *
     * Update scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \Swagger\Client\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Swagger\Client\Model\ResponseDocument, HTTP status code, HTTP response headers (array of strings)
     */
    public function updateSubstitutionsUsingPUTWithHttpInfo($authorization, $organization_id, $ids, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->updateSubstitutionsUsingPUTRequest($authorization, $organization_id, $ids, $data);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Swagger\Client\Model\ResponseDocument',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation updateSubstitutionsUsingPUTAsync
     *
     * Update scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSubstitutionsUsingPUTAsync($authorization, $organization_id, $ids, $data)
    {
        return $this->updateSubstitutionsUsingPUTAsyncWithHttpInfo($authorization, $organization_id, $ids, $data)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation updateSubstitutionsUsingPUTAsyncWithHttpInfo
     *
     * Update scheduling substitutions (Unavailable/Replacement)
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function updateSubstitutionsUsingPUTAsyncWithHttpInfo($authorization, $organization_id, $ids, $data)
    {
        $returnType = '\Swagger\Client\Model\ResponseDocument';
        $request = $this->updateSubstitutionsUsingPUTRequest($authorization, $organization_id, $ids, $data);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'updateSubstitutionsUsingPUT'
     *
     * @param  string $authorization Basic Authorization header (required)
     * @param  int $organization_id The id of the Organization that owns this resource (required)
     * @param  string $ids The id or ids (comma delimmited) of the resources to update (required)
     * @param  \Swagger\Client\Model\HttpRequestBody $data A substitution object to be updated. Supports partial updates - one or more fields may be included in the request and only the fields specified will be updated. To remove a field, the field must be explicitly passed with a null value. PUT is treated as PATCH as object replacement is not supported. (required)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function updateSubstitutionsUsingPUTRequest($authorization, $organization_id, $ids, $data)
    {
        // verify the required parameter 'authorization' is set
        if ($authorization === null || (is_array($authorization) && count($authorization) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $authorization when calling updateSubstitutionsUsingPUT'
            );
        }
        // verify the required parameter 'organization_id' is set
        if ($organization_id === null || (is_array($organization_id) && count($organization_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organization_id when calling updateSubstitutionsUsingPUT'
            );
        }
        // verify the required parameter 'ids' is set
        if ($ids === null || (is_array($ids) && count($ids) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $ids when calling updateSubstitutionsUsingPUT'
            );
        }
        // verify the required parameter 'data' is set
        if ($data === null || (is_array($data) && count($data) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $data when calling updateSubstitutionsUsingPUT'
            );
        }

        $resourcePath = '/scheduling/{organizationId}/substitutions/{ids}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // header params
        if ($authorization !== null) {
            $headerParams['Authorization'] = ObjectSerializer::toHeaderValue($authorization);
        }

        // path params
        if ($organization_id !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organization_id),
                $resourcePath
            );
        }
        // path params
        if ($ids !== null) {
            $resourcePath = str_replace(
                '{' . 'ids' . '}',
                ObjectSerializer::toPathValue($ids),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($data)) {
            $_tempBody = $data;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['*/*']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['*/*'],
                ['application/json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            
            if($headers['Content-Type'] === 'application/json') {
                // \stdClass has no __toString(), so we should encode it manually
                if ($httpBody instanceof \stdClass) {
                    $httpBody = \GuzzleHttp\json_encode($httpBody);
                }
                // array has no __toString(), so we should encode it manually
                if(is_array($httpBody)) {
                    $httpBody = \GuzzleHttp\json_encode(ObjectSerializer::sanitizeForSerialization($httpBody));
                }
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
